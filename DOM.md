<h2>What is dompurify?</h2>

DOMPurify is an XSS-Sanitizer for HTML, MathML and SVG. You can feed DOMPurify with a string full of dirty HTML, and it will return a string (unless configured otherwise) with clean HTML.

Example:

```javascript
var no_xss = DOMPurify.sanitize(xss);
```

DOMPurify contains a whitelist of HTML tags that it considers safe and allows in the sanitized output. This includes common tags like `<p>, <b>, <i>, <h1>,` etc. Sometimes you may wanna whitelist tags that are not already present in this whitelist. You can use the `ADD_TAGS` parameter for that.

For example, suppose for whatever reason I don't want to sanitize `<script>` tags from my input. Then I can write:

```javascript
DOMPurify.sanitize(XSS, { ADD_TAGS: ['script'] });
```

This won't remove script tags from the XSS input now.

<br>
<hr>
<br>

Note: Well I just realized DOMPurify has an additional safety feature that prevents you from adding harmful tags like `<script>` to the whitelist using `ADD_TAGS`. So the above example won't work for script tags, but tags like `<template>, <slot>, <shadow>, <picture>,` etc can be added to the whitelist if wanted.

<br>
<hr>
<br>

Similarly, you can also forbid specific tags which are present in the whitelist. If I want the `<h1>` tags to be sanitized, I can just write:

```javascript
DOMPurify.sanitize(XSS, { FORBID_TAGS: ['h1'] });
```

You can do the same thing for attributes using `ALLOWED_ATTR` and `FORBID_ATTR`.

<br>
<hr>
<br>

Note: Even `<a>` is considered a whitelisted tag in DOMPurify, because they've blacklisted the attribute `href`.

Example:

```javascript
const XSS = '<a href="javascript:alert(1)">XSS</a>';
var No_XSS = DOMPurify.sanitize(XSS, { ALLOWED_ATTR: ['href'] });
console.log(No_XSS);
```

Output:
`<a>XSS</a>`

Ig without `href`, the `<a>` tag is rendered useless. Attributes like `onclick` are blacklisted as well.

<br>
<hr>
<br>

<h2>What are math tags?</h2>

The `<math>` tags are part of MathML, which is a markup language used to display mathematical and scientific content on the web.

Example:

```html
<math>
  <mrow>
    <msup>
      <mi>x</mi>
      <mn>2</mn>
    </msup>
    <mo>+</mo>
    <msup>
      <mi>y</mi>
      <mn>2</mn>
    </msup>
  </mrow>
  <mo>=</mo>
  <msup>
    <mi>z</mi>
    <mn>2</mn>
  </msup>
</math>
```

This will display the formula `x^2 + y^2 = z^2`.

The `<math>` tag accepts attributes like `class, id, style, dir, href, display, mode, and overflow`.

<br>
<hr>
<br>

DOMPurify mutation XSS bypass can be achieved via MathML namespace confusion. Mutation XSS exploits abuse browser defaults and parsing differences.

Everything I've gotten below is from a blog. I read the blog, found it interesting, and I'm just writing my understandings: https://research.securitum.com/mutation-xss-via-mathml-mutation-dompurify-2-0-17-bypass/

Ok so DOMPurify is mostly used with     `innerHTML` (makes sense, why else would you need to sanitize it). Normally, the code used somewhat looks like this:

```javascript
div.innerHTML = DOMPurify.sanitize(htmlMarkup)
```

Here,
1. htmlMarkup is passed to the DOM Tree.
2. XSS causing nodes are deletd.
3. DOM Tree is serialized back to HTML.
4. The clean DOM Tree is appended to the document DOM Tree.

For example if htmlMarkup is 
```html
A<img src=1 onerror=alert(1)>B
```

First its parsed into a tree:

<p align = 'center'>

![](<Images/htmlMarkup DOM Tree.png>)

</p>

XSS causing thingies are removed:

<p align = 'center'>

![](<Images/Cleaned DOM Tree.png>)

</p>

Then it is serialized to `	
A<img src="1">B` and consequently appends its tree to the document.

Here's where mutation XSS comes to play. We first get the sanitized DOM tree, we serialize it, then we parse it into a DOM Tree again. Problem is, the two trees may not be the same. Don't know why, but its normally due to a parse or serialization error. This is how mutation XSS was created, by exploiting this.

Ooh okay this is cool. So, everyone knows the `<form>` tag. Now the `<form>` tag has a specification. You cannot nest a form inside a form.

For example, if you convert the following to its DOM tree:

```html
<form id='form1'>
    INSIDE_FORM1
    <form id='form2'>
        INSIDE_FORM2
```

Its tree will be:

<p align = 'center'>

![](<Images/Nested FORM DOM Tree.png>)

</p>

So it completely neglects form2. This is because we haven't closed form1. When a `<form>` tag is opened, its opened with a form element pointer, whose value is not null. When a `<form>` tag is closed, the value becomes null, allowing for a new form to be opened if need be.

```html
<form id="outer"><div></form><form id="inner"><input>
```

Now, in the above code snippet, a form outer is opened, then a div element, then the `<form>` tag is closed. This means the form element pointer has a null value, allowing us to open another form. Now since div is under the outer form, and inner form is under div, technically, we have nested the two forms.

<p align = 'center'>

![](<Images/Actually Nested FORM DOM Tree.png>)

</p>

Trying to serialize this DOM Tree, we'll get 

```html
<form id="outer"><div><form id="inner"><input></form></div></form>
```

Then converting this to a DOM Tree, we get a different one, without any nested forms. This is an example of how serialization of a DOM Tree doesn't really have to yield the same DOM Tree.

This is called a `spec-compliant mutation`. And you can make use of this to bypass HTML sanitizers, aka, DOMPurify.

Now why did I enter all this while talking about MathML? Well, we can exploit this bypass using the MathML and SVG namespaces.

Ok so the HTML parser can create a DOM Tree with elements of three namespaces:

- HTML
- SVG
- MathML

```html
<style><a>ABC</style><svg><style><a>ABC
```

results in the following DOM Tree:

<p align = 'center'>

![](Images/Namespaces.png)

</p>

In the HTML namespace, style cannot have child elements, but SVG style can.

Here, what I thought is if you specify a namespace, every single child element under that namespace will be of that namespace. Like, everything under `<svg>` will belong to the SVG namespace and everything under `<math>` will belong to the MathML namespace. But no, not exactly.

In MathML, there are certain text integration points that convert the child elements of `<math>` to MathML namespace. These points are:

- `math mi`
- `math mo`
- `math mn`
- `math ms`

There are also HTML Integration Points which switch to HTML namespace:

- `math annotation-xml` if it has an attribute called encoding whose value is equal to either text/html or application/xhtml+xml
- `svg foreignObject`
- `svg desc`
- `svg title`

I think this is what it is, I don't completely understand this.

The children of MathML text integration points are by default in HTML namespace with two exceptions: `mglyph` and `malignmark`.

```html
<math>
<mtext>
<mglyph></mglyph>
<a><mglyph>
```

DOM Tree:

<p align = 'center'>

![](<Images/Math DOM Tree.png>)

</p>

Rules highlighted in the blog:

- Current element is in the namespace of its parent unless conditions from the points below are met. This I get.

- If current element is `<svg>` or `<math>` and parent is in HTML namespace, then current element is in SVG or MathML namespace respectively. Okayy, got this.

- If parent of current element is an HTML integration point, then current element is in HTML namespace unless it’s `<svg>` or `<math>`. Okayy.

- If parent of current element is an MathML integration point, then current element is in HTML namespace unless it’s `<svg>, <math>, <mglyph> or <malignmark>`. I don't get the difference between MathML integration points and HTML integration points.

- If current element is one of `<b>, <big>, <blockquote>, <body>, <br>, <center>, <code>, <dd>, <div>, <dl>, <dt>, <em>, <embed>, <h1>, <h2>, <h3>, <h4>, <h5>, <h6>, <head>, <hr>, <i>, <img>, <li>, <listing>, <menu>, <meta>, <nobr>, <ol>, <p>, <pre>, <ruby>, <s>, <small>, <span>, <strong>, <strike>, <sub>, <sup>, <table>, <tt>, <u>, <ul>, <var> or <font>` with color, face or size attributes defined, then all elements on the stack are closed until a MathML text integration point, HTML integration point or element in HTML namespace is seen. Then, the current element is also in HTML namespace. Don't get this.

<br>

Now the DOMPurify Bypass: (MISHA REMEMBER THIS FOR FUTURE USE)

```html
<form><math><mtext></form><form><mglyph><style></math><img src onerror=alert(1)>
```

<p align = 'center'>

![](<Images/Bypass Initial DOM Tree.png>)

</p>

Here, all elements are allowed by DOMPurify. So no sanitation is needed.

Resulting serialization:

```html
<form><math><mtext><form><mglyph><style></math><img src onerror=alert(1)></style></mglyph></form></mtext></math></form>
```

This is what DOMPurify returns. When its parsed by innerHTML, the resulting DOM Tree is:

<p align = 'center'>

![](<Images/Bypass Final DOM Tree.png>)

</p>

When this is appended to the document DOM Tree, XSS will be possible.

What I don't understand is, can't this be solved by just looping until previous serialization matches the next serialization? Just add that to DOMPurify functionality and you're good.

<br>
<hr>
<br>

<h2>What are glyphs?</h2>

In MathML, glyphs are used to represent mathematical characters. The `<mglyph>` tag is used for the same.

<h2>What is DOM?</h2>

DOM (Document Object Model) is a cross-platform, language independent application programming interface that treats an HTML, XHTML, or XML documents as a tree structure. It's a web document programming interface. It represents the page for the programs that modify and create the structure of the document (script and style) and its content. The DOM is how programming languages can communicate with the document as nodes and objects.

DOM is an object model and programming interface for HTML documents. It is used to present the web page in a structurally hierarchical form so that both developers and users can easily use the document. Using HTML DOM, we can control tags, IDs, classes, attributes, and elements of HTML easily by command or methods given by the document object.

Javascript is not able to directly understand the HTML document. It reads the DOM, written by the browser in response to the HTML document and interacts with it. DOM is practically the same as our HTML document except this html document represented in a tree-structure which is made of objects. JavaScript organizes itself in the DOM objects, even it understands the tags in the document of HTML. (This also explains why the above process is  used, parsing, serialization, parsing. Cause mXSS could be prevented without the parsing, and just looking at the serialized code snippet. However JS can't really read it, so skill issue.)

Idrk what else to write :(.

<h2>What's a DOM Parser?</h2>

A DOM Parser is a tool that reads HTML or XML documents and converts them into DOM structure. The DOM is a tree-like representation of the document, where each node in the tree corresponds to a part of the document, such as an element, attribute, or piece of text.

When you parse a document with a DOM parser, you get back a tree structure that contains all of the elements of your document. This tree structure is a live representation of the document, meaning that changes to the tree are immediately reflected in the document, and vice versa.

The DOM Parser provides a variety of functions you can use to examine the contents and structure of the document. For example, you can traverse the DOM tree to access specific elements, modify the content or attributes of elements, add new elements, or remove existing elements.

One of the main benefits of using a DOM parser is that it allows you to work with HTML or XML documents in a structured, programmatic way. Instead of dealing with raw text or string manipulation, you can work with objects and methods that represent the structure and content of the document.

However, because the DOM parser loads the entire document into memory, it can be inefficient for large documents. For such cases, other types of parsers like SAX (Simple API for XML) or streaming parsers may be more appropriate.

<h2>How does any parser convert HTML to an actual dom?</h2>

1. The parser reads the HTML document as a string of characters and breaks it down into distinct pieces called tokens. Each token represents a different part of the document, such as a start tag, end tag, attribute name, attribute value, or text.

2. The parser takes these tokens and uses them to build a DOM Tree. Each token is turned into a node in the DOM tree. The type of the node is determined by the type of token.

3. As the parser reads the HTML document from top to bottom, it adds nodes to the DOM tree. When it encounters a start tag, it creates a new element node and adds it as a child of the current node. If it encounters an end tag, it moves back up to the parent node. Text and attribute nodes are added as children of the element node they belong to.

4. If the parser encounters malformed HTML, it will try to correct the errors and continue building the DOM tree. This error handling process is defined by the HTML specification and is designed to ensure that even poorly formed HTML can still be parsed into a usable DOM.

5. If the parser encounters a `<script>` tag while building the DOM, it will pause the DOM construction, execute the script, and then resume the DOM construction. This is because scripts can manipulate the DOM and affect the way the rest of the document is parsed.

<h2>What part of the dom parser makes the decision making of handling errors?</h2>

The part of the DOM parser that handles errors is known as the error handling mechanism or error recovery. This mechanism is built into the HTML parsing algorithm defined by the HTML specification.

When the parser encounters malformed HTML, such as an attribute without quotes like `<img=a>`, it doesn't just stop or throw an error. Instead, it uses a set of rules defined in the HTML specification to correct the error and continue parsing. This process is known as "error recovery".

In the case of an attribute without quotes, the parser will automatically add the missing quotes around the attribute value. So, `<img=a>` becomes `<img="a">`. This is done to ensure that the resulting DOM is a well-formed tree structure, even if the original HTML was not well-formed.

<h2>Choose a dom parser, preferably one using by browsers/dompurify and illustrate how <br>
1. a good html <br>
2. a bad html i.e. one missing quotes, opening, closing tags
gets rendered</h2>

When the parser encounters good HTML, it reads the HTML document from top to bottom, tokenizing the markup into distinct pieces. It then uses these tokens to construct the DOM tree. Each token becomes a node in the DOM tree, with the type of node determined by the type of token. 

For example:

```html
<html>
<head>
  <title>Hello World</title>
</head>
<body>
  <h1>Hello</h1>
  <p>World</p>
</body>
</html>
```

In this well-formed HTML, each tag becomes an element node in the DOM tree, and the text inside the tags becomes text nodes.

<br>

When the parser encounters bad HTML, such as missing quotes around attribute values or missing closing tags, it uses a set of error-handling rules to correct the errors and continue parsing. 

For example:

```html
<html>
<head>
    <title>Hello World</title>
</head>
<body>
    <h1>Hello
    <p>World</p>
</body>
</html>
```

In this malformed HTML, the closing `</h1>` tag is missing. The parser will automatically insert a closing `</h1>` tag before the `<p>` tag, ensuring that the resulting DOM tree is well-formed. This is also seen in the exploit above.

Similarly, if an attribute value is missing quotes (like `<img src=a>`), the parser will automatically add the missing quotes around the attribute value (`<img src="a">`).