<font size = '4'>
<p align = "center">
<b>
Express JS Starter Pack
</b>
</p>
</font>

<br>
<font size = '3'>

- https://expressjs.com/en/starter/hello-world.html
- https://www.codecademy.com/article/what-is-crud
- https://expressjs.com/en/guide/database-integration.html
- https://stackoverflow.com/questions/39870867/what-does-app-usebodyparser-json-do
- https://developer.mozilla.org/en-US/docs/Web/HTTP/Status
- https://planetscale.com/blog/how-to-prevent-sql-injection-attacks-in-node-js
- https://stackoverflow.com/questions/41677815/how-to-loop-through-node-js-array
- https://stackoverflow.com/questions/3010840/loop-through-an-array-in-javascript
- https://stackoverflow.com/questions/36858508/how-to-send-a-parameter-in-html-link-and-how-to-retrieve-it

Error:<br>
- ReferenceError: title is not defined<br>
Solution: https://stackoverflow.com/questions/37732986/ejs-js-referenceerror-title-not-defined<br><br>

<b>Rewriting code to prevent SQL Injection:</b><br>
<br>
Original code for updating record:

    const bID = parseInt(req.params.id);

    const { title, author } = req.body;

    const updateData = [];

    const lettersAndNumbersPattern = /^[A-Za-z0-9]+$/;

    if (title) updateData.push(`title = '${title}'`);
    if (author) updateData.push(`author = '${author}'`);

    query = `UPDATE books SET ${updateData.join(', ')} WHERE id = ?`;

New code for updating record:

    const bID = parseInt(req.params.id);

    const { title, author } = req.body;

    const updateData = [];

    const lettersAndNumbersPattern = /^[A-Za-z0-9]+$/;

    // Added code to check for special characters to prevent sqli
    if(!title.match(lettersAndNumbersPattern) || !author.match(lettersAndNumbersPattern)) {
        return res.status(400).json({ err: "No special characters please!"});
    }

    if (title) updateData.push(`title = '${title}'`);
    if (author) updateData.push(`author = '${author}'`);

    query = `UPDATE books SET ${updateData.join(', ')} WHERE id = ?`;

<br><br><br>

Updating code to prevent SQL Injection using placeholders:

New code:

    app.put('/books/:id', (req, res) => {

        const bID = parseInt(req.params.id);

        const { title, author } = req.body;

        if (title) {
            query = `UPDATE books SET title = ? WHERE id = ?`;
            db.run (query, [title, bID], (err) => {
                if (err) {
                    console.error(err.message);
                    return res.status(500).send('Error updating book record');
                }
    
                console.log(`Book title updated`);
            });
        }

        if (author) {
            query = `UPDATE books SET author = ? WHERE id = ?`;
            db.run (query, [author, bID], (err) => {
                if (err) {
                    console.error(err.message);
                    return res.status(500).send('Error updating book record');
                }
    
                console.log(`Book author updated`);
            }); 
        }

        res.status(200).send('Book updated successfully');
    });

XSS (Cross Site Scripting) Vulnerability:

Types of XSS:

1. Stored XSS - Malicious scripts are saved on the website's server, often in a database.
2. Reflected XSS - Malicious scripts are included in a URL or input fields and are not stored on the server.
3. DOM-based XSS - The attack occurs on the client side, manipulating the Document Object Model (DOM) of a web page.

DOM-based XSS was showing up cause I used the innerHTML method, which interpreted the user input as HTML code. Fixed this using the following changes to the get endpoint:

    async function getAllBooks() {
      const response = await fetch('/books');
      const data = await response.json();

      const container = document.createElement('div');

      for (var i = 0; i < data.length; i++) {
          //console.log(data[i]);
          const bookInfo = document.createElement('div');
          bookInfo.textContent = data[i].id + ". " + data[i].title + " - " + data[i].author;
          container.appendChild(bookInfo);
          const lineBreak = document.createElement('br');
          container.appendChild(lineBreak);
      }

      const result = document.getElementById('getAllBooksResult');
      result.innerHTML = '';
      result.appendChild(container);
    }

I created an empty container (a div element) that I'll use to hold the data. For each book, we create another smaller div element to hold the book id, title, and author, as a raw string. We append this to the original container, then create a lineBreak container to store the br element, and append that as well. This way, any HTML code gets converted to raw string.

Added the code snippet:

    const urlParams = new URLSearchParams(window.location.search);
    const q = urlParams.get('q');

    //console.log(q);

    if (q) {
      document.getElementById('getBookByQuery').value = q;
      getBookByQuery();
    } 
    else {
      const pathParams = window.location.pathname.split('/');

      console.log (pathParams);
      const pathQuery = pathParams[pathParams.length - 1];

      if (pathQuery && !pathQuery.includes('?')) {
        document.getElementById('getBookByQuery').value = pathQuery;
        getBookByQuery();
      }
    }

It is able to retrieve search query using the URL http://localhost:2220/?q=book-name.
Unable to retrieve search query using http://localhost:2220/book-name.

Created a login page with JWT. Problem was, I could easily navigate to the /books.html URL by simply changing the URL. After a lot of trial and error, figured I had to invoke the token for every function as a header, and added the token as a parameter in the URL to use the URLSearchParams() function. (Kinda used a wee bit of ChatGPT for this).

<br><hr><br>
<h4> 24/02/24 </h4>

-- Added code to randomize secretKey:<br>
    
    const randomKey = (length) => {
        let r = '';
        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        const len = chars.length;
         for (let i = 0; i < length; i++) {
            r += chars.charAt(Math.floor(Math.random() * len));
        }
        return r;
    };

<br>

-- Used relative path for db file:

    const db = new sqlite3.Database('CRUD.db', sqlite3.OPEN_READWRITE);

<br>

-- Removed token from the url by storing in local session for one hour.

-- Created registration page. Problem is, I have used the following function:

    function verifyToken(req, res, token) {
    

    if (req.path === '/register') {
      return next();
    }

    if (!token) {
      return res.status(401).json({ error: 'Token is required' });
    }
  
    jwt.verify(token, secretKey, (err, decoded) => {
      if (err) {
        return res.status(403).json({ error: 'Invalid token' });
      }
  
      
    });
    }

This function redirects to the login page if no token is found. I want to bypass it for the registration page. Honestly, way too sick of JS to think about it further. Will figure out a way later.

-- Created a USERS table to store username and passwords of users. Current usernames and passwords are:<br>
    
    - Misha: pass1234
    - Anaya: 1234
    - Idk: Idk2

</font>