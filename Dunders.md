<h2>Q1. What is the purpose of  `__xyz__` double underscored variables stuff in python?</h2>

Magic methods, or dunders (double underscores) in python are defined by built-in classes in Python, and are commonly used for operator overloading. One can use dunder methods to customize the behavior of common operations such as +, -, *, **, ==, %, @ and more. These methods don't have to be explicitly called, and are automatically called when certain operators and / or operations are used.


```python
class calc:
    def __init__(self, n):
        self.n = n
    
    def __add__(self, n2):
        return self.n - n2.n
    
    def __sub__(self, n2):
        return self.n + n2.n
    
    def __mul__(self, n2):
        return self.n * n2.n

n1 = calc(10)
n2 = calc(5)

n3 = n1 + n2
n4 = n1 - n2
n5 = n1 * n2

print(n3)
print(n4)
print(n5)

```

Output:
```
5
15
50
```

In this code, I overwrote the meanings of the operators `+` and `-` using dunders and interchanged them for chaotic purposes. But yeah, dunders mainly allow you to edit such common functionalities as your program calls for it.
<br><br>

<h2>Q2. Read up on all of these, try them out in python console, and write a brief expl + a code snippet showing their usage for the top 10(in solving chals) important ones among them according to your research.</h2>

```python
__init__,__del__,__repr__,__str__,__call__,__len__,__getitem__,__setitem__,__delitem__,__iter__,__next__,__getattr__,__setattr__,__delattr__,__dir__,__enter__,__exit__,__bool__,__format__,__doc__,__class__,__module__,__bases__,__import__,__name__,__qualname__,__annotations__,__dict__,__slots__,__weakref__,__reduce__,__reduce_ex__,__copy__,__deepcopy__,__slots__,__mro__,__globals__,__builtins__
```

According to me, the top 10 are:

<h3>1. `__init__`</h3>

The most commonly used dunder, used for initialization of an object after it has been created. It is automatically called when an object is created.

```python
class calc:
    def __init__(self, n):
        self.n = n
        print (self.n)

n1 = calc("hello")
```

Output:
```
hello
```

(Mostly used for initializing, another dunder is used for printing. Just wanted to show how its automatically invoked when an object is created.)

<h3>2. `__str__`</h3> 

This method returns a string representation of an object. It is invoked by the print() function or the str() function.

```python
class calc:
    def __init__(self, n):
        self.n = n
    
    def __str__(self):
        return "Hello World"

n1 = calc("Anything byt hello world")
print (n1)
```

Output:

```
Hello World
```

<h3>3. `__call__`</h3>

This allows a classâ€™s instance to be called like a function, not a method.

```python
class calc:
    def __init__(self, n):
        self.n = n
    
    def __call__(self, n2):
        return self.n * n2

n1 = calc(10)
n2 = n1(5)
print (n2)
```

Output:
```
50
```

<h3>4. `__getitem__`</h3>

This method allows objects to implement custom behaviour for accessing their elements like how one would a list.

```python
class calc:
    def __init__(self, n):
        self.n = n
    
    def __getitem__(self, n2):
        return self.n[n2]

n1 = calc([1, 2, 3])

print (n1[0])
print (n1[1])
```

Output:
```
1
2
```

<h3>5. `__setitem__`</h3>

This method allows the user to update the value of the object's elements as one would a list element.

```python
class calc:
    def __init__(self, n):
        self.n = n
    
    def __setitem__(self, index, n2):
        self.n[index] = n2

n1 = calc([1, 2, 3])
n1[2] = 5

print (n1.n)
```

Output:
```
[1, 2, 5]
```

<h3>6. `__delitem__`</h3>

Similar to the previous two, this one is used to delete an element as one would a list.

```python
class calc:
    def __init__(self, n):
        self.n = n
    
    def __delitem__(self, index):
        del self.n[index]

n1 = calc([1, 2, 3])
del n1[2]

print (n1.n)
```

Output:
```
[1, 2]
```

I chose the last 3 methods particularly because these allow one to interact with class instances as they were lists, giving us more control over the data. I assume it may be useful in CTFs at one point.

<h3>7.`__iter__` and `__next__`:</h3>

These two methods go hand-in-hand. As the name suggests, they're used to make a class iterable.

```python
class calc:
    def __init__(self, n):
        self.n = n
        self.index = 0
    
    def __iter__ (self):
        return self
    
    def __next__(self):
        if self.index >= len(self.n):
            raise StopIteration
        item = self.n[self.index]
        self.index += 1
        return item

n1 = calc([1, 2, 3])

for i in n1:
    print (i)
```

Output:
```
1
2
3
```

<h3>8. `__getattr__`</h3>

This is used to dynamically access the attributes of an object, kinda how a dictionary functions.

```python
class calc:
    def __init__(self, n):
        self.n = n
    
    def __getattr__(self, n2):
        if n2 in self.n:
            return self.n[n2]
        else:
            print ("Does not exist")

n1 = calc({'name': 'Misha', 'age': 18})

print (n1.name)
print (n1.city)
```

Output:
```
Misha
Does not exist
None
```

The None is being printed as python did not find the attribute, and I didn't raise an error.

<h3>9. `__slots__`</h3>

This method is used to explicitly declare the attributes of an instance, and to limit the attributes that can be assigned to an instance.

```python
class calc:
    __slots__ = ['name', 'age']
    
    def __init__(self, name, age):
        self.name = name
        self.age = age

n1 = calc("Misha", 18)
print (n1.name)

n1.city = "Pune"
```

Output:
```
Misha
Traceback (most recent call last):
  File "c:\Users\misha\Desktop\Important Stuff\Python Programs\Test.py", line 11, in <module>
    n1.city = "Pune"
    ^^^^^^^
AttributeError: 'calc' object has no attribute 'city'
```

<h3>10. `__name__`</h3>

This is mainly used to print the name of the module being run. This dunder is commonly seen in programs as:

```python
def hello():
    print("Hello World")

if __name__ == "__main__":
    hello()
```

Output:
```
Hello World
```