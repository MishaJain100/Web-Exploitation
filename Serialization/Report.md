<h2>Encoding vs Serialisation?</h2>

- Encoding refers to converting a certain stream of data (text, images, videos) into another stream of data. It deals with the compression and encryption of that particular data.
- Serialisation is used to convert objects with certain structure into a storable or transmissible form. It is mainly used to save and load files, send data over a network, and to store data in a database. I suppose its used to convert complex data structures like arrays, objects, and other data having similar structure, to a linear format.

<h2>The various methods to convert an object in memory to a file and then read that file back into an object:</h2>

- C++:
    - To write object's data members to a file:
    ```C++
    obj.write((char *) & class_obj, sizeof(class_obj));
    ```
    - In this, the object `obj` is an instance of the output stream class `std::ofstream`.
    - `class_obj` is an object of the class. Its address is being assigned to a pointer.
    - `char *` is used to treat the address of `class_obj` as a pointer to a sequence of characters (bytes).
    - `sizeof(class_obj)` basically tells the write function how many bytes to write from class_obj.

    <br>

    - To read object's data members from a file:
    ```C++
    obj.read((char *) & class_obj, sizeof(class_obj));
    ```
    - Follows the same steps as above, except the write function is replaced by the read function, and `obj` is an instance of inpute stream class `std::ifstream`.

    <br>

    - Example:
    ```C++
    #include <iostream>
    #include <fstream>
    using namespace std;

    class testClass {
    public:
        int a;
        double b;
    };

    int main() {
        testClass class_obj;
        class_obj.a = 27;
        class_obj.b = 27.10;

        ofstream obj_out("output.bin", ios::binary);
        obj.write((char *) & class_obj, sizeof(class_obj));
        obj.close();

        testClass class_obj2;
        ifstream obj_in("output.bin", ios::binary);
        obj_in.read((char *) & class_obj2, sizeof(class_obj2));
        obj_in.close();

        cout << "a: " << class_obj2.a << ", b: " << class_obj2.b << endl;

        return 0;
    }

    ```

    <p align = 'center'>

    ![](Images/output_cpp.png)

    </p>

- Python:
    - To write object's data members to a file:
    ```python
    pickle.dump(obj, f)
    ```
    - `pickle` is a library imported for object serialization/deserialization.
    - `dump()` is used to serialize `obj` and write them to the file `f`. There is a method called `dumps()` which is used to represent the object as a byte object.

    <br>

    - To read object's data members from a file:
    ```python
    obj = pickle.load(f)
    ```
    - Similar to above, `load()` is used to read from a file, and `loads()` is used to deserialize from byte object.

    <br>

    - Example:
    ```python
    import pickle 

    class testClass:
        def __init__ (self, a, b):
            self.a = a
            self.b = b

    obj = testClass(27, 27.10)

    with open('output_py.bin', 'wb') as f:
        pickle.dump(obj, f)
        f.close()

    with open('output_py.bin', 'rb') as f:
        obj2 = pickle.load(f)
        print (f"a: {obj2.a}, b: {obj2.b}")
        f.close()
    ```

    <p align = 'center'>

    ![](Images/output_py.png)

    </p>

- Java:
    - To write object's data members to a file:
    ```java
    FileOutputStream f = new FileOutputStream("output_java.bin");
    ObjectOutputStream obj_out = new ObjectOutputStream(f);
    obj_out.writeObject(class_obj);
    obj_out.close();
    fileOut.close();
    ```
    - `FileOutputStream` and `ObjectOutputStream` are two classes that are imported from java.io package.
    - `f` is an object of FileOutputStream class and `obj_out` is an object of the ObjectOutputStream class.
    - `writeObject()` is writing `class_obj` to the file.
    
    <br>

    - To read object's data members from a file:
    ```java
    FileInputStream f = new FileInputStream("output_java.bin");
    ObjectInputStream obj_in = new ObjectInputStream(f);
    obj = (testClass) in.readObject();
    in.close();
    fileIn.close();
    ```
    - Similar to previous, just classes are replaced with the respective input classes.

    <br>

    - Example:
    ```java
    // testClass.java

    import java.io.Serializable;

    public class testClass implements Serializable {
        private int a;
        private double b;

        public testClass(int a, double b) {
            this.a = a;
            this.b = b;
        }

        public int getA() {
            return a;
        }

        public double getB() {
            return b;
        }
    }   

    // Read_Write.java

    import java.io.FileOutputStream;
    import java.io.FileInputStream;
    import java.io.ObjectOutputStream;
    import java.io.ObjectInputStream;
    import java.io.IOException;

    public class Read_Write {

        public static void main(String[] args) {
            try {
                testClass obj = new testClass(27, 27.10);

                FileOutputStream fileOut = new FileOutputStream("output_java.bin");
                ObjectOutputStream obj_out = new ObjectOutputStream(fileOut);
                obj_out.writeObject(obj);
                obj_out.close();
                fileOut.close();

                FileInputStream fileIn = new FileInputStream("output_java.bin");
                ObjectInputStream obj_in = new ObjectInputStream(fileIn);
                testClass obj2 = (testClass) obj_in.readObject();
                obj_in.close();
                fileIn.close();

                System.out.println("a: " + obj2.getA() + ", b: " + obj2.getB());
            } catch (IOException | ClassNotFoundException e) {
                e.printStackTrace();
            }
        }
    }
    ```

    <p align = 'center'>

    ![](Images/output_java.png)

    </p>

<h2>Python Pickle Library</h2>

Python has a module called pickle to dump objects after serialization. Serialization is the process of converting a python object into a byte stream and deserialization (or unpickling in python terminology) is the inverse process i.e. converting a byte stream to python object (as stated above). This saves Python objects to a file and allows them to be transmitted over a network, and then restores them later.

When an object is pickled, it is converted into a byte stream. The pickle module supports various data types, including lists, dictionaries, classes, and user-defined objects. This is accomplished through a combination of Python's built-in data structures and custom serialization logic for more complex objects.

A pickled file contains a sequence of opcodes (operation codes) that represent the serialized object.

The basic structure of a pickled object, (as given below) follows the basic format of having bytes to represent the header, bytes to represent argument structure, and a stop code, to mark the end

```python
import pickle

arr = bytes([ 0x80, 0x04, 0x95, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5D, 0x94, 0x28, 0x4B, 0x01, 0x4B, 0x02, 0x7D, 0x94, 0x8C, 0x03, 0x63, 0x61, 0x74, 0x94, 0x8C, 0x05, 0x6D, 0x6F, 0x75, 0x73, 0x65, 0x94, 0x73, 0x65, 0x2E])

print (pickle.loads(arr))
```

<p align = 'center'>

![](<Images/pickle_array output.png>)

</p>

Here,
- 0x80, 0x04: Used to denote protocol version 5

- 0x95, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00: Frame opcode, 26 bytes

- 0x5D, 0x94: Indicates the start of a list (as seen in the output above) (Empty list initially)

- 0x28: Indicates the start of a tuple

- 0x4B, 0x01: BINPUT, Integer 1

- 0x4B, 0x02: BINPUT, Integer 2

- 0x7D: Indicates an empty dictionary

- 0x94: Saves the object to memo

- 0x8C, 0x03, 0x63, 0x61, 0x74: For string 'cat'

- 0x94: Saves the object to memo

- 0x8C, 0x05, 0x6D, 0x6F, 0x75, 0x73, 0x65: For string 'mouse'

- 0x94: Saves the object to memo

- 0x73: Adds to the list

- 0x65: Sets the item in the dictionary

- 0x2E: STOP