<h2>Encoding vs Serialisation?</h2>

- Encoding refers to converting a certain stream of data (text, images, videos) into another stream of data. It deals with the compression and encryption of that particular data.
- Serialisation is used to convert objects with certain structure into a storable or transmissible form. It is mainly used to save and load files, send data over a network, and to store data in a database. I suppose its used to convert complex data structures like arrays, objects, and other data having similar structure, to a linear format.

<h2>The various methods to convert an object in memory to a file and then read that file back into an object:</h2>

- C++:
    - To write object's data members to a file:
    ```C++
    obj.write((char *) & class_obj, sizeof(class_obj));
    ```
    - In this, the object `obj` is an instance of the output stream class `std::ofstream`.
    - `class_obj` is an object of the class. Its address is being assigned to a pointer.
    - `char *` is used to treat the address of `class_obj` as a pointer to a sequence of characters (bytes).
    - `sizeof(class_obj)` basically tells the write function how many bytes to write from class_obj.

    <br>

    - To read object's data members from a file:
    ```C++
    obj.read((char *) & class_obj, sizeof(class_obj));
    ```
    - Follows the same steps as above, except the write function is replaced by the read function, and `obj` is an instance of inpute stream class `std::ifstream`.

    <br>

    - Example:
    ```C++
    #include <iostream>
    #include <fstream>
    using namespace std;

    class testClass {
    public:
        int a;
        double b;
    };

    int main() {
        testClass class_obj;
        class_obj.a = 27;
        class_obj.b = 27.10;

        ofstream obj_out("output.bin", ios::binary);
        obj.write((char *) & class_obj, sizeof(class_obj));
        obj.close();

        testClass class_obj2;
        ifstream obj_in("output.bin", ios::binary);
        obj_in.read((char *) & class_obj2, sizeof(class_obj2));
        obj_in.close();

        cout << "a: " << class_obj2.a << ", b: " << class_obj2.b << endl;

        return 0;
    }

    ```

    <p align = 'center'>

    ![](Images/output_cpp.png)

    </p>

- Python:
    - To write object's data members to a file:
    ```python
    pickle.dump(obj, f)
    ```
    - `pickle` is a library imported for object serialization/deserialization.
    - `dump()` is used to serialize `obj` and write them to the file `f`. There is a method called `dumps()` which is used to represent the object as a byte object.

    <br>

    - To read object's data members from a file:
    ```python
    obj = pickle.load(f)
    ```
    - Similar to above, `load()` is used to read from a file, and `loads()` is used to deserialize from byte object.

    <br>

    - Example:
    ```python
    import pickle 

    class testClass:
        def __init__ (self, a, b):
            self.a = a
            self.b = b

    obj = testClass(27, 27.10)

    with open('output_py.bin', 'wb') as f:
        pickle.dump(obj, f)
        f.close()

    with open('output_py.bin', 'rb') as f:
        obj2 = pickle.load(f)
        print (f"a: {obj2.a}, b: {obj2.b}")
        f.close()
    ```

    <p align = 'center'>

    ![](Images/output_py.png)

    </p>

- Java:
    - To write object's data members to a file:
    ```java
    FileOutputStream f = new FileOutputStream("output_java.bin");
    ObjectOutputStream obj_out = new ObjectOutputStream(f);
    obj_out.writeObject(class_obj);
    obj_out.close();
    fileOut.close();
    ```
    - `FileOutputStream` and `ObjectOutputStream` are two classes that are imported from java.io package.
    - `f` is an object of FileOutputStream class and `obj_out` is an object of the ObjectOutputStream class.
    - `writeObject()` is writing `class_obj` to the file.
    
    <br>

    - To read object's data members from a file:
    ```java
    FileInputStream f = new FileInputStream("output_java.bin");
    ObjectInputStream obj_in = new ObjectInputStream(f);
    obj = (testClass) in.readObject();
    in.close();
    fileIn.close();
    ```
    - Similar to previous, just classes are replaced with the respective input classes.

    <br>

    - Example:
    ```java
    // testClass.java

    import java.io.Serializable;

    public class testClass implements Serializable {
        private int a;
        private double b;

        public testClass(int a, double b) {
            this.a = a;
            this.b = b;
        }

        public int getA() {
            return a;
        }

        public double getB() {
            return b;
        }
    }   

    // Read_Write.java

    import java.io.FileOutputStream;
    import java.io.FileInputStream;
    import java.io.ObjectOutputStream;
    import java.io.ObjectInputStream;
    import java.io.IOException;

    public class Read_Write {

        public static void main(String[] args) {
            try {
                testClass obj = new testClass(27, 27.10);

                FileOutputStream fileOut = new FileOutputStream("output_java.bin");
                ObjectOutputStream obj_out = new ObjectOutputStream(fileOut);
                obj_out.writeObject(obj);
                obj_out.close();
                fileOut.close();

                FileInputStream fileIn = new FileInputStream("output_java.bin");
                ObjectInputStream obj_in = new ObjectInputStream(fileIn);
                testClass obj2 = (testClass) obj_in.readObject();
                obj_in.close();
                fileIn.close();

                System.out.println("a: " + obj2.getA() + ", b: " + obj2.getB());
            } catch (IOException | ClassNotFoundException e) {
                e.printStackTrace();
            }
        }
    }
    ```

    <p align = 'center'>

    ![](Images/output_java.png)

    </p>

<h2>Python Pickle Library</h2>

Python has a module called pickle to dump objects after serialization. Serialization is the process of converting a python object into a byte stream and deserialization (or unpickling in python terminology) is the inverse process i.e. converting a byte stream to python object (as stated above). This saves Python objects to a file and allows them to be transmitted over a network, and then restores them later.

When an object is pickled, it is converted into a byte stream. The pickle module supports various data types, including lists, dictionaries, classes, and user-defined objects. This is accomplished through a combination of Python's built-in data structures and custom serialization logic for more complex objects.

A pickled file contains a sequence of opcodes (operation code) that represent the serialized object.

```python
arr = bytes([ 0x80, 0x04, 0x95, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5D, 0x94, 0x28, 0x4B, 0x01, 0x4B, 0x02, 0x7D, 0x94, 0x8C, 0x03, 0x63, 0x61, 0x74, 0x94, 0x8C, 0x05, 0x6D, 0x6F, 0x75, 0x73, 0x65, 0x94, 0x73, 0x65, 0x2E])
```

Here,
0x80: Protocol version (4)
0x04: Indicates pickle protocol version 4
0x95: Frame opcode, followed by 8-byte frame length
0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00: Frame length (26 bytes)
0x5D: MARK, indicates the start of a list
0x94: Empty list []
0x28: STARTTUPLE, indicates a tuple
0x4B, 0x01: BINPUT, integer 1
0x4B, 0x02: BINPUT, integer 2
0x7D: EMPTY_DICT, indicates an empty dictionary
0x94: MEMOIZE, saves the object to memo
0x8C, 0x03, 0x63, 0x61, 0x74: SHORT_BINUNICODE, string 'cat'
0x94: MEMOIZE, saves the object to memo
0x8C, 0x05, 0x6D, 0x6F, 0x75, 0x73, 0x65: SHORT_BINUNICODE, string 'mouse'
0x94: MEMOIZE, saves the object to memo
0x73: APPEND, adds to the list
0x65: SETITEM, sets the item in the dictionary
0x2E: STOP, indicates the end of the pickle
Pickle Protocols and Security
Pickle supports several protocols, each optimized for different versions of Python and different use cases:

Protocol 0: Human-readable (ASCII).
Protocol 1: Binary format.
Protocol 2: Introduced in Python 2.3, supports new-style classes.
Protocol 3: Introduced in Python 3.0, adds support for bytes objects.
Protocol 4: Introduced in Python 3.4, includes large object support.
Protocol 5: Introduced in Python 3.8, includes support for out-of-band data.
One crucial consideration when using pickle is security. Since pickle can execute arbitrary code during deserialization, loading pickled data from untrusted sources can lead to code execution vulnerabilities. It's generally recommended to use safer serialization formats like JSON or libraries like jsonpickle if security is a concern.